<?php# AUTHOR: RICARDO AZZI ## CREATED: 15/10/12 #class Math {	//Fatorial	public function Factorial($number) {		if ($number == 0) {			return 1;		}				else if (is_numeric($number)) {			$result = 1;			for ($i = 1; $i <= $number; $i++) {				$result = $result * $i;			}						return $result;		}				else {			return FALSE;		}	}		//Combinação	public function Combine($n, $s) {		if ($n > 0 AND $s >= 0 AND $s <= $n AND is_numeric($n) AND is_numeric($s)) {			return (Math::Factorial($n))/(Math::Factorial($s)*Math::Factorial($n - $s));		}				else { return FALSE; }	}			//Converte byte para string hexadecimal	public function byte2hex($byte) {		$hex = dechex($byte);		if (strlen($hex) == 1) {			$hex = $hex."0";		}		return strtoupper($hex);	}		//Conversão de byte para inteiro 16 unsigned	public function byte2UInt16($byte1, $byte2) {		if ($byte1 < 256 AND $byte2 < 256) {			$retorna = pack("C", $byte1);			$retorna .= pack("C", $byte2);			$retorna = unpack("S", $retorna);			return $retorna[1];		} else {			return false;		}	}		//Conversão de byte para inteiro 16 signed	public function byte2SInt16($byte1, $byte2) {		if ($byte1 < 256 AND $byte2 < 256) {			$retorna = pack("C", $byte1);			$retorna .= pack("C", $byte2);			$retorna = unpack("s", $retorna);			return $retorna[1];		} else {			return false;		}	}		//Conversão de byte para inteiro 32 unsigned	public function byte2UInt32($byte1, $byte2, $byte3, $byte4) {		if ($byte1 < 256 AND $byte2 < 256 AND $byte3 < 256 AND $byte4 < 256) {			$retorna = pack("C", $byte1);			$retorna .= pack("C", $byte2);			$retorna .= pack("C", $byte3);			$retorna .= pack("C", $byte4);			$retorna = unpack("I", $retorna);			return $retorna[1];		} else {			return false;		}	}		//Conversão de byte para inteiro 32 signed	public function byte2SInt32($byte1, $byte2, $byte3, $byte4) {		if ($byte1 < 256 AND $byte2 < 256 AND $byte3 < 256 AND $byte4 < 256) {			$retorna = pack("C", $byte1);			$retorna .= pack("C", $byte2);			$retorna .= pack("C", $byte3);			$retorna .= pack("C", $byte4);			$retorna = unpack("i", $retorna);			return $retorna[1];		} else {			return false;		}	}		//Conversão de byte para inteiro 64 unsigned	public function byte2UInt64($byte1, $byte2, $byte3, $byte4, $byte5, $byte6, $byte7, $byte8) {		if ($byte1 < 256 AND $byte2 < 256 AND $byte3 < 256 AND $byte4 < 256 AND $byte5 < 256 AND $byte6 < 256 AND $byte7 < 256 AND $byte8 < 256) {			$retorna = pack("C", $byte1);			$retorna .= pack("C", $byte2);			$retorna .= pack("C", $byte3);			$retorna .= pack("C", $byte4);			$retorna .= pack("C", $byte5);			$retorna .= pack("C", $byte6);			$retorna .= pack("C", $byte7);			$retorna .= pack("C", $byte8);			$retorna = unpack("L", $retorna);			return $retorna[1];		} else {			return false;		}	}		//Conversão de byte para inteiro 64 signed	public function byte2SInt64($byte1, $byte2, $byte3, $byte4, $byte5, $byte6, $byte7, $byte8) {		if ($byte1 < 256 AND $byte2 < 256 AND $byte3 < 256 AND $byte4 < 256 AND $byte5 < 256 AND $byte6 < 256 AND $byte7 < 256 AND $byte8 < 256) {			$retorna = pack("C", $byte1);			$retorna .= pack("C", $byte2);			$retorna .= pack("C", $byte3);			$retorna .= pack("C", $byte4);			$retorna .= pack("C", $byte5);			$retorna .= pack("C", $byte6);			$retorna .= pack("C", $byte7);			$retorna .= pack("C", $byte8);			$retorna = unpack("L", $retorna);			return $retorna[1];		} else {			return false;		}	}}?>